=== Message routing

Internally, {prodName} only deals with queues and addresses and has no specific internal representation of a subscriptions (or topics).  {prodName} queues have associated with them, an address filter, a unique name and a list of consumers.  When {prodName} receives a message, it is "routed" to all queues that have a matched address filter.  This results in each queue, that matches the message's address, receiving a reference to the original message.  Once a message reference is routed to a queue, it is forwarded to *one* of the queues consumers.

Point to Point Routing

In order to offer point to point semantics, a single queue is created with a particular address, say “jms.queue.foo”.  Clients that want to consume from this address are added to the queues consumer list.  When a messages is received,  that that matches the queue's address filter, it is routed this single queue.  The message on this queue is then forwarded to one of it's consumers (as described above) creating “point to point” style message semantics.  The key thing here is that, many consumers share a single queue, creating the following relationships:

Address (1 → 1) Queue (1 → many) Consumers

Subscription Routing

Since {prodName} does not have an internal object representation of a subscription (or topic), subscriptions are typically layered on top of core queues, and are implemented in the protocol managers (or for JMS, in the {prodName} JMS client).  Subscription behaviour is typically acheived by creating dedicated consumer queues (vs shared queues as described above).  Each new client subscription results in the creation of a new queue (with the subscription address), a consumer is then associated with this dedicated queue.  The queue contains, the subscription address filter, a single associated consumer and a unique queue name (usually client-id : address) .   This creates the following relationships.

Address (1→many) Queue (1 → 1) Consumers.

=== JMS

Messages sent to a {brokerName} are routed dependant on the address specified in the address which can differ depending on
the protocol used. Since primarily the broker was written to support JMS there are some nuances as to how addressing works.

=== Queue Addressing with JMS

If you create a JMS Queue using the management console or via JMX, lets say `myQueue`, then this will create the JMS management
 view of the JMS Queue will show it as called `myQueue`. However, since the JMS Management layer is just a facade built
 on top of the Core management Layer it hides some of the details, specifically a prefix that is added to the core queues name.
 Looking at a screenshot of the management console you can see the prefix `jms.queue.` has been added:

image::queues.png[JMS Queue Management]

==== Sending messages to Queues

When using the {prodName} JMS client the same prefixing happens transparently. So for instance if you were sending a
message to the JMS queue `myQueue` then this is the name that should be used. so for instance if you were using JNDI this
would be an entry in the `jndi.properties` file like this:

-----
queue.queue/myQueue=myQueue
-----

The same name would be used programmatically, any message sent to this address would be prefixed with `jms.queue.` by the
client before sending.

When using the OpenWire client the jms name `myQueue` should also be used. The prefix `jms.queue.` will be added when the
message arrives at the broker beofore it is routed.

> **Note**
>
> Since the prefix is always added it is currently not possible to send messages to core queues that don't have the `jms.queue.` prefix

For all other clients the prefix needs to be added by the client so in this case the address would be `jms.queue.myQueue`.

==== Consuming messages from Queues

When using the JMS client the same prefixing happens transparently. So for instance if you were consuming a
message from the JMS queue `myQueue` then this is the name that should be used.

When using the OpenWire client the jms name `myQueue` should also be used. The prefix `jms.queue.` will be added when the
message arrives at the broker beofore it is routed.

> **Note**
>
> Since the prefix is always added it is currently not possible to consume messages from core queues that don't have the `jms.queue.` prefix

For all other clients the prefix needs to be added by the client so in this case the address would be `jms.queue.myQueue`.

=== Topic Addressing with JMS

If you create a JMS Topic using the management console or via JMX, lets say `myTopic`, then this will create the JMS management
 view of the JMS Topic and will show it as called `myTopic`. However, since the JMS Management layer is just a facade built
 on top of the Core management Layer it hides some of the details. Since there is no concept of topics at a core level
 there will not be an associated core topic object, however there will be a core queue created using the prefix `jms.topic.`
 which is just used for management purposes and no messages will ever be routed to it.

image::topics.png[JMS Topic Management]

Subscriptions on a topic are implemented as core queues so for every so for every subscription that exists there will an
associated core queue named by connection ids and client ids (dependant on the protocol) or a randon UUID if the subscription
is volatile.

==== Sending messages to Topics

When using the JMS client the same prefixing happens transparently. So for instance if you were sending a
message to the JMS topic `myTopic` then this is the name that should be used. so for instance if you were using JNDI this
would be an entry in the `jndi.properties` file like this:

-----
topic.topic/myTopic=myTopic
-----

The same name would be used programmatically, any message sent to this address would be prefixed with `jms.topic.` by the
client before sending.

==== Consuming messages from Topics

Since there is no notion of topics at a core level on the broker, only the JMS facade, then how subscriptions are handled
differs depending on the protocol used to receive messages.

===== JMS Client

When using the JMS client the `jms.topic.` prefixing is added transparently by the client. The Client itself will then create
a subscription queue, using its connectionid and client id if durable or a random UUID if non durable, and bind it to the
address `jms.topic.myTopic`.

===== Openwire Clients

When using the OpenWire client the same naming convention is used the only difference is this is applied at the broker side
so the client should use the topic name `myTopic`. The subscription queues are created by the broker in this case rather
than the client.

===== AMQP Clients

Any receiving link that attaches to an address with the prefix `jms.topic.` will be treated as a subscription and a
subscription queue will be created by the broker. If the Terminus Durability is either UNSETTLED_STATE
or CONFIGURATION then the queue will be made durable, similar to a JMS durable subscription and given a name made up from
the container id and the link name, something like `my-container-id:my-link-name`. if the Terminus Durability is configured
as NONE then a volatile queue will be created.

The prefix used can be configured on the Acceptor.

===== MQTT Clients

MQTT is subscription based so //todo

===== STOMP Clients

Since STOMP is subscription based then subscription queues are always created, if the following SUBSCRIBE frane is sent:

-----
SUBSCRIBE
id:myId
destination:jms.topic.myTopic
ack:client

^@
-----

Then the STOMP client will subscribe to the JMS Topic myTopic and the broker will create a subscription queue with the
name `myId`.




